#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <chrono>

// Include the header file generated by DBToaster
#include "sales_view.hpp"

// A simple helper function to get a field from a stringstream
template<typename T>
T get_field(std::stringstream& ss) {
    T val;
    std::string field;
    std::getline(ss, field, '|');
    std::stringstream field_ss(field);
    field_ss >> val;
    return val;
}

int main(int argc, char* argv[]) {
    // --- 1. Setup and Data Paths ---
    std::string data_path = "data/"; // Assumes data is in a 'data' subdirectory
    std::string products_path = data_path + "products.dat";
    std::string sales_path = data_path + "sales.dat";
    std::string updates_path = data_path + "updates.dat";

    // Create an instance of the DBToaster program
    dbtoaster::Program p;
    dbtoaster::Program::snapshot_t snap;

    // --- 2. Load Initial Data ---
    std::cout << "Loading initial data..." << std::endl;
    std::string line;

    // Load products.dat (Stream ID 0)
    std::ifstream products_file(products_path);
    while (std::getline(products_file, line)) {
        std::stringstream ss(line);
        dbtoaster::event_t e;
        e.type = dbtoaster::event_type_t::insert;
        e.id = 0; // Stream ID for PRODUCTS
        e.data.insert_PRODUCTS.P_ID = get_field<long>(ss);
        e.data.insert_PRODUCTS.P_NAME = get_field<dbtoaster::STRING_TYPE>(ss);
        e.data.insert_PRODUCTS.P_CATEGORY = get_field<dbtoaster::STRING_TYPE>(ss);
        p.process_event(e);
    }
    products_file.close();
    std::cout << "Loaded " << products_path << std::endl;

    // Load sales.dat (Stream ID 1)
    std::ifstream sales_file(sales_path);
    while (std::getline(sales_file, line)) {
        std::stringstream ss(line);
        dbtoaster::event_t e;
        e.type = dbtoaster::event_type_t::insert;
        e.id = 1; // Stream ID for SALES
        e.data.insert_SALES.S_ID = get_field<long>(ss);
        e.data.insert_SALES.P_ID = get_field<long>(ss);
        e.data.insert_SALES.S_AMOUNT = get_field<double>(ss);
        p.process_event(e);
    }
    sales_file.close();
    std::cout << "Loaded " << sales_path << std::endl;
    
    // --- 3. Process Update Stream and Benchmark ---
    std::cout << "\nProcessing update stream and measuring maintenance rate..." << std::endl;
    long update_count = 0;
    std::ifstream updates_stream(updates_path);

    // Start the timer
    auto start = std::chrono::high_resolution_clock::now();

    while (std::getline(updates_stream, line)) {
        update_count++;
        std::stringstream ss(line);
        dbtoaster::event_t e;

        int stream_id = get_field<int>(ss);
        int event_type = get_field<int>(ss);

        e.id = stream_id;
        e.type = (event_type == 1) ? dbtoaster::event_type_t::insert : dbtoaster::event_type_t::del;
        
        // This example assumes updates only happen to the SALES table (stream 1)
        if (stream_id == 1) { 
             e.data.insert_SALES.S_ID = get_field<long>(ss);
             e.data.insert_SALES.P_ID = get_field<long>(ss);
             e.data.insert_SALES.S_AMOUNT = get_field<double>(ss);
        }
        // Add an 'else if' block here for updates to other tables if needed

        p.process_event(e);
    }
    updates_stream.close();

    // Stop the timer
    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> diff = end - start;

    // --- 4. Report Results ---
    double throughput = update_count / diff.count();
    std::cout << "\n--- Benchmark Results ---" << std::endl;
    std::cout << "Processed " << update_count << " updates in " << diff.count() << " seconds." << std::endl;
    std::cout << "Maintenance Rate (Throughput): " << std::fixed << throughput << " updates/second." << std::endl;

    // --- 5. Print the Final Maintained View ---
    snap = p.get_snapshot();
    std::cout << "\n--- Final View Content (TotalSalesByCategory) ---" << std::endl;
    snap.TotalSalesByCategory.foreach([](const TotalSalesByCategory_entry& e) {
        // The _1 and _2 are default names from DBToaster for SUM aggregates
        std::cout << "Category: " << e.P_CATEGORY << ", Total Sales: " << e.__av0 << std::endl;
    });

    return 0;
}